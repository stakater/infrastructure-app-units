input {
        beats {
                port => {{key /logstash/beatsPort}}
        }
}
filter {
  if [type] == "syslog" {
      grok {
          match => { "message" => "{{key "/logstash/syslogPattern"}}" }
          overwrite => ["message"]
          remove_tag => [ "_grokparsefailure" ]
      }
  }
  mutate {
      gsub => [ "app_name", "[-:].*", "" ]
      gsub => [ "message", "\\n", "
" ]
      lowercase => [ "app_name" ]
  }
  if !("_grokparsefailure" in [tags]) {
    {{range $index, $app := ls "/logstash"}}
      if [app_name] == "{{ $app }}"  {
        {{$multilineKey := printf "/logstash/%s/multilinePattern" $app }}{{$grokKey := printf "/logstash/%s/grokPattern" $app }}
        {{ if keyExists $multilineKey }}
          multiline {
              pattern => "{{key $multilineKey}}"
              negate => true
              what => "previous"
          }
       {{ end }}{{ if keyExists $grokKey }}
         grok {
            match => { "message" => "{{key $grokKey }}" }
            overwrite => ["message"]
            remove_tag => [ "_grokparsefailure" ]
          }
       {{ end }}
      }
    {{ end }}{{$grokKey := "/logstash/defaultPattern" }}
    {{ if keyExists $grokKey }}
      else {
          grok {
              match => { "message" => "{{key $grokKey }}" }
              overwrite => ["message"]
              remove_tag => [ "_grokparsefailure" ]
          }
      }
    {{ end }}
    date {
      timezone => "UTC"
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm:ss,SSS", "ISO8601", "yyyy/MM/dd HH:mm:ss", "UNIX", "dd/MMM/yyyy:HH:mm:ss.SSS"]
      target => "@timestamp"
      remove_field => ["timestamp"]
    }
  }
}
output {
      stdout { }
      elasticsearch {
              hosts => [{{range $index, $service := service "elasticsearch-9200"}}{{if ne $index 0}},{{end}}"{{.Address}}"{{end}}]
      }
}